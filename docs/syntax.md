# Metapipe Syntax

The syntax for .mp files is as follows.


# Structure

Each command in the pipeline should be on their own line and have the following
structure:

```
[command alias] command [flags] {input/output pattern} 

Example
-------

1. cut -f 1 some_file > {o}
```

In this example, the command cut is given the alias `1` and cuts column 1 
from `some_file` and puts it in an output file called `some_file.1`.

**Note:** The alias for a file can be anything, as long as it's unique in the
pipeline.


## Input Patterns

Consider the following command:

```
>COMMANDS:
python somescript {some_file1.txt||some_file2.txt||some_file3.txt}

>FILES:
some_file1.txt
some_file2.txt
some_file3.txt
```

This command will run the python script 3 times in parallel, once with each 
file specified. The output will look something like this:

```
Output
------

python somescript some_file1.txt
python somescript some_file2.txt
python somescript some_file3.txt
```

Files can also be labeled for simpler commands.

```
>COMMANDS:
python somescript {a||b||c}

>FILES:
a. some_file1.txt
b. some_file2.txt
c. some_file3.txt

Output
------

>>> python somescript some_file1.txt
>>> python somescript some_file2.txt
>>> python somescript some_file3.txt
```

Files are given implicit labels by default as well.

```
>COMMANDS:
python somescript {1||2||3}

>FILES:
some_file1.txt
some_file2.txt
some_file3.txt

Output
------

>>> python somescript some_file1.txt
>>> python somescript some_file2.txt
>>> python somescript some_file3.txt
```

If a command should use *all* of the input files in some way, then the syntax
is even easier.

```
>COMMANDS:
python somescript {*||}

>FILES:
some_file1.txt
some_file2.txt
some_file3.txt

Output
------

>>> python somescript some_file1.txt
>>> python somescript some_file2.txt
>>> python somescript some_file3.txt
```


### Running a script with multiple inputs

Let's say that you have a script with takes multiple files as input. In this
case the syntax becomes:

```
>COMMANDS:
python somescript {*,}

>FILES:
some_file1.txt
some_file2.txt
some_file3.txt

Output
------

>>> python somescript some_file1.txt some_file2.txt some_file3.txt
```

You can also specify combined files explicitly.

```
>COMMANDS:
python somescript {1,2,3}

>FILES:
some_file1.txt
some_file2.txt
some_file3.txt

Output
------

>>> python somescript some_file1.txt some_file2.txt some_file3.txt
```


### Multiple steps and file names



## Output Patterns

Whenever a script would take an explicit output filename you can use the output
pattern syntax to tell metapipe where/what it should use.

```
>COMMANDS:
python somescript -o {o} {*||}

>FILES:
some_file1.txt
some_file2.txt
some_file3.txt

Output
------

python somescript -o some_file1.1 some_file1.txt
python somescript -o some_file2.1 some_file2.txt
python somescript -o some_file3.1 some_file3.txt
```

Metapipe will generate the filename by stripping the file extension and
appending the command label to the filename.


### Implicit or Hardcoded output

In a case where the script or command you want to use generates an output that
is not passed through the command, but you need to use for another step in the
pipeline, you can use output patterns to tell metapipe what to look for.

Consider this:

```
>COMMANDS:
./do_count {*||}
./analyze.sh {1.*}


>FILES:
foo.txt
bar.txt
```

This set of commands is invalid because the second command (`./analyze.sh`)
doesn't know what the output of command 1 is because it isn't specified.
The split command generates output based on the input filenames it is given.

Since we wrote the `./do_count` script, we know that it generates files with a
`.counts` extension. But since we don't explicitly specify the files, in
this case Metapipe cannot assume the file names generated by step 1 and this
config file is invalid.

We can tell metapipe what the output should look like by using the `$INPUT`
variable and the output tag.

```
>COMMANDS:
./do_counts {*||} {o:*.counts}
./analyze.sh {1.*||}

>FILES:
foo.txt
bar.txt
```

The above example tells metapipe that the output of command 1, which is
hardcoded in the script will have an output that ends in `.counts`. Now that
the output of command 1 is known, command 2 can use them by name.

When the output marker has the form `{o}`, then metapipe will insert a
pregenerated filename to the command. The output marker `{o:<pattern>}` means
that the output of the script is *not* determined by the input of the script,
but it *will* match given pattern. This means that later commands will be able
to reference the files by name.

It's important to note that the output pattern marking is optional. If the user
already knows the output of the commands, then careful use of the `wait on` marker
and the input pattern markers can achieve the same thing and is a more flexible
system. 


## Magic Comments

When submitting jobs, metapipe uses the systems' default options for memory,
scratch space, and CPU time. Metapipe also performs various behaviors such as,
by default, not overriding previous files and not cleaning up tmp files. If
your needs are different from these defaults, you can use Magic Comments to 
override them to better fit your needs.

**Important:** Magic comments cascade from where they appear. If they appear
before a command, they will apply to that command and all that follow unless
overriden. Magic comments that appear at the top will effect all commands.


### Syntax

The syntax for Magic Comments is as follows:

```
# This is a regular comment
#{This is a magic comment}


#{CLEANUP}
#{MEM 64G}
#{CPU 100H}
#{SCRATCH 25G}
```

Magic comments *must be in all caps and inside the curly braces*. Anything
outside the curly braces is ignored. The Magic Comments must also be the first
thing on their respective lines and cannot have a space between the `#` and the
curly brace.


#### Chaining Magic Comments

For a more compact syntax, Magic Comments can also be chained on one line.

```
#{CLEANUP, MEM 64G, CPU 100H}
```

The same rules apply as with normal magic comments, the only difference being
that magic comments can be chained if they are seperated with a comma. Space
between the options is optional, but preffered for clarity.


### List of Magic Comments

- `#{CLEANUP}`: (Default off) When enabled, metapipe will clean up all files
  generated during the analysis except from the last step. Note: This only
applies to tracked files. Any files that are generated and not tracked (i.e.
logs) are not cleaned up since Metapipe doesn't know about them.

- `#{MEM <number><unit>}`: (Default system dependent) Explicitly specifies the
  amount of memory to be given to a command and all that follow unless
overridden. Units are: K,M,G,T for Kilo, Mega, Giga, and Terabytes respectivly.   

- `#{CPU <number><unit>}`: (Default system dependent) Explicitly specifies the
  CPU time that should be given to a job. As of now, the only unit supported is
H (hours) and the maximum is dependent on the queue system you use (usually
999H).

- `#{SCRATCH <number><unit>}`: (Default system dependent) Specifies the amount
  of scratch space that a given job will be given. Supported units are the same
as the units for the `MEM` command. 


# Sample config.mp file

``` 
# Lines beginning with # signs are comments.
# Analyzes Sassafrass files.
# <author>
# TODO: Add Notes.

# These are *magic comments.*
#{CLEANUP}
#{STOP_ON_ERR}
#{NO_RETRY}

# File.Step - Naming convention for files

>COMMANDS:
# Cut all the files listed in the files list and save them to another file.
1. cut -f 1 {||} > {o}

# For each of those files, run a given Python script (each file is
independent).
2. python {1.*||} > {o}

# Once all those files are done, run the analysis on them.
3. htseq -fgt -o {o} {2.*,}

# To get the results, run another script for each .counts file generated by #2.
4. ./analyze_counts -o {o} -i {3.*.counts||}

# For files 1,3,4,5,6,9 run the last step.
5. cat {4.1,4.3-6,4.9} | grep 'sassafrass' | python analyze_sassafrass.py -o {o.finalized}

# You can even reuse files from other steps.
6. cat {4.1,3.2||3.4,5.6||1.1,1} >> somefile

# No explicitly specified output file
7. python blah_blah.py {*.6} {o: *.6.counts }

>FILES:
1: SAMPLE_1.csv
2: SAMPLE_2.csv
3: SAMPLE_3.csv
4: SAMPLE_4.csv
5: SAMPLE_5.csv
Label1: SAMPLE_6.csv
Label2: SAMPLE_7.csv
Label3: SAMPLE_8.csv

>PATHS:
python: python_path
htseq: htseq_path
```
